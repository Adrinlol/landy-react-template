{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport * as React from 'react';\n/**\n * Cache `value` related LabeledValue & options.\n */\n\nexport default (function (labeledValues, valueOptions) {\n  var cacheRef = React.useRef({\n    values: new Map(),\n    options: new Map()\n  });\n  var filledLabeledValues = React.useMemo(function () {\n    var _cacheRef$current = cacheRef.current,\n        prevValueCache = _cacheRef$current.values,\n        prevOptionCache = _cacheRef$current.options; // Fill label by cache\n\n    var patchedValues = labeledValues.map(function (item) {\n      if (item.label === undefined) {\n        var _prevValueCache$get;\n\n        return _objectSpread(_objectSpread({}, item), {}, {\n          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label\n        });\n      }\n\n      return item;\n    }); // Refresh cache\n\n    var valueCache = new Map();\n    var optionCache = new Map();\n    patchedValues.forEach(function (item) {\n      valueCache.set(item.value, item);\n      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));\n    });\n    cacheRef.current.values = valueCache;\n    cacheRef.current.options = optionCache;\n    return patchedValues;\n  }, [labeledValues, valueOptions]);\n  var getOption = React.useCallback(function (val) {\n    return valueOptions.get(val) || cacheRef.current.options.get(val);\n  }, [valueOptions]);\n  return [filledLabeledValues, getOption];\n});","map":{"version":3,"sources":["/Users/iflego/Documents/GitHub/landy-react-template/my-app/node_modules/rc-select/es/hooks/useCache.js"],"names":["_objectSpread","React","labeledValues","valueOptions","cacheRef","useRef","values","Map","options","filledLabeledValues","useMemo","_cacheRef$current","current","prevValueCache","prevOptionCache","patchedValues","map","item","label","undefined","_prevValueCache$get","get","value","valueCache","optionCache","forEach","set","getOption","useCallback","val"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,0CAA1B;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA;AACA;AACA;;AAEA,gBAAgB,UAAUC,aAAV,EAAyBC,YAAzB,EAAuC;AACrD,MAAIC,QAAQ,GAAGH,KAAK,CAACI,MAAN,CAAa;AAC1BC,IAAAA,MAAM,EAAE,IAAIC,GAAJ,EADkB;AAE1BC,IAAAA,OAAO,EAAE,IAAID,GAAJ;AAFiB,GAAb,CAAf;AAIA,MAAIE,mBAAmB,GAAGR,KAAK,CAACS,OAAN,CAAc,YAAY;AAClD,QAAIC,iBAAiB,GAAGP,QAAQ,CAACQ,OAAjC;AAAA,QACIC,cAAc,GAAGF,iBAAiB,CAACL,MADvC;AAAA,QAEIQ,eAAe,GAAGH,iBAAiB,CAACH,OAFxC,CADkD,CAGD;;AAEjD,QAAIO,aAAa,GAAGb,aAAa,CAACc,GAAd,CAAkB,UAAUC,IAAV,EAAgB;AACpD,UAAIA,IAAI,CAACC,KAAL,KAAeC,SAAnB,EAA8B;AAC5B,YAAIC,mBAAJ;;AAEA,eAAOpB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiB,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAChDC,UAAAA,KAAK,EAAE,CAACE,mBAAmB,GAAGP,cAAc,CAACQ,GAAf,CAAmBJ,IAAI,CAACK,KAAxB,CAAvB,MAA2D,IAA3D,IAAmEF,mBAAmB,KAAK,KAAK,CAAhG,GAAoG,KAAK,CAAzG,GAA6GA,mBAAmB,CAACF;AADxF,SAA9B,CAApB;AAGD;;AAED,aAAOD,IAAP;AACD,KAVmB,CAApB,CALkD,CAe9C;;AAEJ,QAAIM,UAAU,GAAG,IAAIhB,GAAJ,EAAjB;AACA,QAAIiB,WAAW,GAAG,IAAIjB,GAAJ,EAAlB;AACAQ,IAAAA,aAAa,CAACU,OAAd,CAAsB,UAAUR,IAAV,EAAgB;AACpCM,MAAAA,UAAU,CAACG,GAAX,CAAeT,IAAI,CAACK,KAApB,EAA2BL,IAA3B;AACAO,MAAAA,WAAW,CAACE,GAAZ,CAAgBT,IAAI,CAACK,KAArB,EAA4BnB,YAAY,CAACkB,GAAb,CAAiBJ,IAAI,CAACK,KAAtB,KAAgCR,eAAe,CAACO,GAAhB,CAAoBJ,IAAI,CAACK,KAAzB,CAA5D;AACD,KAHD;AAIAlB,IAAAA,QAAQ,CAACQ,OAAT,CAAiBN,MAAjB,GAA0BiB,UAA1B;AACAnB,IAAAA,QAAQ,CAACQ,OAAT,CAAiBJ,OAAjB,GAA2BgB,WAA3B;AACA,WAAOT,aAAP;AACD,GA1ByB,EA0BvB,CAACb,aAAD,EAAgBC,YAAhB,CA1BuB,CAA1B;AA2BA,MAAIwB,SAAS,GAAG1B,KAAK,CAAC2B,WAAN,CAAkB,UAAUC,GAAV,EAAe;AAC/C,WAAO1B,YAAY,CAACkB,GAAb,CAAiBQ,GAAjB,KAAyBzB,QAAQ,CAACQ,OAAT,CAAiBJ,OAAjB,CAAyBa,GAAzB,CAA6BQ,GAA7B,CAAhC;AACD,GAFe,EAEb,CAAC1B,YAAD,CAFa,CAAhB;AAGA,SAAO,CAACM,mBAAD,EAAsBkB,SAAtB,CAAP;AACD,CApCD","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport * as React from 'react';\n/**\n * Cache `value` related LabeledValue & options.\n */\n\nexport default (function (labeledValues, valueOptions) {\n  var cacheRef = React.useRef({\n    values: new Map(),\n    options: new Map()\n  });\n  var filledLabeledValues = React.useMemo(function () {\n    var _cacheRef$current = cacheRef.current,\n        prevValueCache = _cacheRef$current.values,\n        prevOptionCache = _cacheRef$current.options; // Fill label by cache\n\n    var patchedValues = labeledValues.map(function (item) {\n      if (item.label === undefined) {\n        var _prevValueCache$get;\n\n        return _objectSpread(_objectSpread({}, item), {}, {\n          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label\n        });\n      }\n\n      return item;\n    }); // Refresh cache\n\n    var valueCache = new Map();\n    var optionCache = new Map();\n    patchedValues.forEach(function (item) {\n      valueCache.set(item.value, item);\n      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));\n    });\n    cacheRef.current.values = valueCache;\n    cacheRef.current.options = optionCache;\n    return patchedValues;\n  }, [labeledValues, valueOptions]);\n  var getOption = React.useCallback(function (val) {\n    return valueOptions.get(val) || cacheRef.current.options.get(val);\n  }, [valueOptions]);\n  return [filledLabeledValues, getOption];\n});"]},"metadata":{},"sourceType":"module"}